"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBrowsers = exports.canNewBrowserBeQueued = exports.createBrowserStackClient = exports.getBrowserStackCredentials = void 0;
const tslib_1 = require("tslib");
const browserstack_1 = require("browserstack");
const util_1 = require("util");
/**
 * Don't use this function directly. Instead, inject the credentials as a dependency.
 */
function getBrowserStackCredentials() {
    return {
        username: process.env.BROWSERSTACK_USERNAME ||
            process.env.BROWSER_STACK_USERNAME ||
            (() => {
                throw new Error('BrowserStack username is empty');
            })(),
        accessKey: process.env.BROWSERSTACK_ACCESS_KEY ||
            process.env.BROWSER_STACK_ACCESS_KEY ||
            (() => {
                throw new Error('BrowserStack access key is empty');
            })(),
    };
}
exports.getBrowserStackCredentials = getBrowserStackCredentials;
function createBrowserStackClient(credentials) {
    return (0, browserstack_1.createAutomateClient)({
        username: credentials.username,
        password: credentials.accessKey,
    });
}
exports.createBrowserStackClient = createBrowserStackClient;
function canNewBrowserBeQueued(credentials, slots, log) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const browserstackClient = createBrowserStackClient(credentials);
        log.debug('calling getPlan');
        const result = yield (0, util_1.promisify)(browserstackClient.getPlan).call(browserstackClient);
        log.debug('getPlan returned:');
        log.debug(JSON.stringify(result));
        const max = result.parallel_sessions_max_allowed;
        const running = result.parallel_sessions_running;
        const canRun = max - running >= slots;
        log.debug('Max queue: ' + max + '. Running: ' + running + '. Required ' + slots + '. Returning: ' + canRun);
        return canRun;
    });
}
exports.canNewBrowserBeQueued = canNewBrowserBeQueued;
function getBrowsers(credentials, log) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const browserstackClient = createBrowserStackClient(credentials);
        log.debug('calling getBrowsers');
        const browsers = yield (0, util_1.promisify)(browserstackClient.getBrowsers).call(browserstackClient);
        log.debug('getBrowsers returned:');
        log.debug(JSON.stringify(browsers));
        return browsers;
    });
}
exports.getBrowsers = getBrowsers;
