"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.retryFailedTests = void 0;
const tslib_1 = require("tslib");
let hasBeenSetAlready = false;
function retryFailedTests(retries, millisecondsBetweenRetries) {
    if (hasBeenSetAlready) {
        return;
    }
    const typelessJasmine = jasmine; // eslint-disable-line @typescript-eslint/no-explicit-any
    const originalSpecConstructor = typelessJasmine.Spec;
    typelessJasmine.Spec = function (attrs) {
        const spec = new originalSpecConstructor(attrs);
        const originalTestFn = spec.queueableFn.fn;
        const runOriginalTest = () => {
            if (originalTestFn.length == 0) {
                return originalTestFn();
            }
            else {
                return new Promise((resolve) => {
                    originalTestFn(resolve);
                });
            }
        };
        spec.queueableFn.fn = function () {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                let exceptionCaught;
                let returnValue;
                for (let i = 0; i < retries; ++i) {
                    spec.reset();
                    returnValue = undefined;
                    exceptionCaught = undefined;
                    try {
                        returnValue = yield runOriginalTest();
                    }
                    catch (exception) {
                        exceptionCaught = exception;
                    }
                    const failed = !spec.markedPending && (exceptionCaught || spec.result.failedExpectations.length != 0);
                    if (!failed) {
                        break;
                    }
                    if (millisecondsBetweenRetries && i != retries - 1) {
                        yield new Promise((resolve) => {
                            setTimeout(resolve, millisecondsBetweenRetries);
                        });
                    }
                }
                if (exceptionCaught) {
                    throw exceptionCaught;
                }
                return returnValue;
            });
        };
        return spec;
    };
    // returns the original message that Jasmine uses to identify pending specs
    typelessJasmine.Spec.pendingSpecExceptionMessage = '=> marked Pending';
    hasBeenSetAlready = true;
}
exports.retryFailedTests = retryFailedTests;
